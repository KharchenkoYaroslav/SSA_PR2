# SSA_PR2

# Звіт по завданням

## Завдання 1

### Ліміт змінної часу

- **64-бітна архітектура**: ліміт змінної часу знаходиться на значенні `9223372036854775807`, яке, на жаль, не можна перевести у час за допомогою `ctime`.
- **32-бітна архітектура**: ліміт часу досягає `Tue Jan 19 05:14:07 2038`.

## Завдання 2

### Аналіз розміру виконуваного файлу

#### Проста програма "Hello, World!" (`task2_1`)
- Загальний розмір виконуваного файлу: **8200 байтів**.
- Основний код міститься в текстовому сегменті (`text`), решта сегментів мінімальні.

#### Додавання глобального масиву із 1000 `int` (`task2_2`)
- Загальний розмір виконуваного файлу збільшився до **8240 байтів**.
- Розмір сегмента **BSS** значно виріс до **4032 байтів** (нульові значення не записуються в сам виконуваний файл).

#### Ініціалізація глобального масиву значеннями (`task2_3`)
- Загальний розмір файлу зріс до **12280 байтів**.
- Значення тепер записані в сегмент **даних** (`data`, **4568 байтів**), що пояснює збільшення файлу.

#### Додавання великого локального масиву у функцію (`task2_4`)
- Загальний розмір файлу: **8360 байтів**.
- Масив без ініціалізації не впливає на розмір виконуваного файлу, але ініціалізація переносить його в сегмент даних.

### Порівняння оптимізацій `-g` та `-O3`

| Параметр | Загальний розмір файлу | Розмір текстового сегмента |
|----------|----------------------|------------------------|
| `-g` (режим налагодження) | 9168 байтів | 1203 байти |
| `-O3` (максимальна оптимізація) | 8312 байтів | 1158 байтів |

- Оптимізація **зменшує розмір** файлу, скорочуючи код.
- Налагоджувальна збірка додає додаткову інформацію для відладки.

## Завдання 3

### Визначення вершини стека (`task3_1`)
- Вершина стека знаходиться приблизно за адресою `0x820e58f1c`.

### Розташування сегментів пам’яті (`task3_2`)
- **Сегмент тексту**: `0x400612` (адреса функції).
- **Сегмент ініціалізованих даних**: `0x401a48`.
- **Сегмент BSS**: `0x401a5c`.
- **Сегмент купи (heap)**: `0x32e9f1008008` (зростає вгору).
- **Сегмент стека (stack)**: `0x820e0e5a4` (росте вниз).

### Зміна вершини стека після збільшення локальних змінних (`task3_3`)
| Стан | Адреса |
|------|---------|
| Початковий стек | `0x8210fba2c` |
| Після виклику функції | `0x8210e8190` |

- Вершина стека **зменшилася**, що підтверджує, що стек росте **вниз**.

## Завдання 4

### Аналіз `backtrace`

#### Виклик функцій:
1. `main(argc=1, argv=0x820436310)` → `task4.c:30`
2. `foo()` → `task4.c:24`
3. `bar()` → `task4.c:18`
4. `bar_is_now_closed()` → `task4.c:12`
5. `_pause()` → `/usr/src/lib/libc/gen/pause.c:51`
6. `_sigsuspend()` → `_sigsuspend.S:4`

#### Висновки:
- Процес заблокований у `pause()`, очікуючи на отримання сигналу.
- Стек росте **зверху вниз** (`main()` → `foo()` → `bar()` → `bar_is_now_closed()` → `pause()`).
- Останній виклик `sigsuspend()` свідчить, що процес "заснув" у стані очікування.

## Завдання 5

### Чому стек не може замінити лічильник команд?
- **Лічильник команд** (PC) відповідає за **лінійне виконання інструкцій**.
- **Стек** працює за принципом **LIFO** (останнім зайшов — першим вийшов).
- Ці структури **призначені для різних цілей** і не можуть замінити одна одну.
- Неможливо реалізувати **багатопоточність** лише за допомогою стека, оскільки кожному потоку потрібен свій лічильник команд.

## Завдання за варіантом 22

### Аналіз ефективності кеш-пам’яті процесора
Програма імітує ситуацію, коли обсяг даних перевищує розмір кешу, вимірюючи час доступу до елементів великого масиву з різними кроками (`stride`).

### Що робить програма?
1. Визначає великий масив (**64M елементів**).
2. Заповнює масив значеннями (`індекс = значення`).
3. Проходить по масиву з різними `stride`, вимірюючи час доступу.
4. Виводить результати.

### Результати `Cache overload test`
| Stride | Time (sec) |
|--------|------------|
| 1 | 15.581222 |
| 2 | 7.993640 |
| 4 | 3.920613 |
| 8 | 2.293759 |
| 16 | 1.814012 |
| 32 | 1.522133 |
| 64 | 0.745607 |
| 128 | 0.408726 |
| 256 | 0.211531 |
| 512 | 0.164052 |
| 1024 | 0.097944 |
| 2048 | 0.045472 |
| 4096 | 0.009010 |

### Аналіз
- **При `stride = 1` доступ займає 15.58 секунд**, оскільки кеш постійно переповнюється.
- **При `stride = 4096` доступ займає 0.009 секунд**, бо використовується мала частина кешу, а решта пам'яті ігнорується.

### Причина ефекту
- **Кеш-пам’ять працює з лінійними блоками (cache lines)**.
- При малих `stride` кеш-промахи часті, що сповільнює роботу.
- При великих `stride` програма використовує лише окремі кеш-лінії, що мінімізує навантаження на кеш.

---

Цей звіт містить детальний аналіз виконаних завдань та висновки щодо ефективності пам'яті та компіляції.

